# See GettingStarted.md for a whole bunch of pointers to understand HTNs, Prolog, etc. This 
# file just describes how to use the framework
from indhtnpy import *
import json
import pprint

# The only class for InductorHtn is called HtnPlanner
# Passing true as the (only) argument turns on debug mode
# Traces of what is happening are sent to the system debug output stream which can be 
# seen on windows with https://docs.microsoft.com/en-us/sysinternals/downloads/debugview
# These traces are much like the standard Prolog traces and will help you understand how 
# the queries and HTN tasks are running and what path they are taking
test = HtnPlanner(False)


# HtnPlanner.HtnCompile()
# Compile a program which includes both HTN and Prolog statements
# The HtnCompile() uses the standard Prolog syntax
# Calling HtnCompile() multiple times will keep adding statements to the database.
# You will get an error if some already exist
prog = """
travel-to(Q) :- 
        if(at(P), walking-distance(P, Q)), 
        do(walk(P, Q)).
    walk(Here, There) :- 
        del(at(Here)), add(at(There)).
    walking-distance(U,V) :- weather-is(good), 
                               distance(U,V,W), =<(W, 3).
    walking-distance(U,V) :- distance(U,V,W), =<(W, 0.5).
    distance(downtown, park, 2).
    distance(downtown, uptown, 8).
    at(downtown).
    weather-is(good).
    """
result = test.HtnCompile(prog)
if result is not None:
    print("HtnCompile Error:" + result)
    sys.exit()

# HtnPlanner.PrologCompile()
# Compile a standard Prolog program and *add* it to the above, just like HtnCompile() does
# PrologCompile() uses all of the Prolog standard syntax
prog = """
    mortal(X) :- human(X).
    human(socrates).
    """
result = test.PrologCompile(prog)
if result is not None:
    print("PrologCompile Error:" + result)
    sys.exit()

####
# Now the database contains *all* of the facts, rules, and tasks from both programs above!
####

# HtnPlanner.FindAllPlans()
# Gets all possible plans that are generated by a query (will return a list of plans, each
# which is a list of terms)
# results are returned in Json format (described farther down)
success, result = test.FindAllPlans("travel-to(park).")
if success is not None:
    print("FindAllPlans error: " + success)
    sys.exit()

solutions = json.loads(result)
print("FindAllPlans result:")
pp = pprint.PrettyPrinter(indent=4)
pp.pprint(solutions)

# HtnPlanner.HtnQuery()
# Run a standard Prolog query using the Htn syntax where variables don't have to be
# capitalized, but must have a ? in front
# results are returned in Json format (described farther down)

# HtnPlanner.PrologQuery()
# Run a standard Prolog query
# results are always returned with a ? in front of the name, however
# results are returned in Json format (described farther down)
success, result = test.PrologQuery("human(Who).")
if success is not None:
    print("PrologQuery error: " + success)
    sys.exit()
answer = json.loads(result)
print("PrologQuery result:")
pp = pprint.PrettyPrinter(indent=4)
pp.pprint(answer)

success, result = test.PrologQuery("at(Where).")
if success is not None:
    print("PrologQuery error: " + success)
    sys.exit()
answer = json.loads(result)
print("PrologQuery result:")
pp = pprint.PrettyPrinter(indent=4)
pp.pprint(answer)

# Results are always returned as Json.  
# Terms are just dictionaries with one key, the name of the term, and one value: a list 
# of more terms
# termName(arg1, arg2) => {"termName":[ {"arg1":[]}, {"arg2":[]} ]}

# Here are some examples:
# term that is a constant (aka a term name with no arguments): e.g. tile
term = json.loads("{\"tile\" : [] }")

# term that is a variable always has a ? in front of it: ?tile
term = json.loads("{\"?tile\" : [] }")

# term with arguments: tile(position(1), 1)
term = {"tile" : [{"position" : [1]}, 1]}

# first arg of known term "tile"
print(term["tile"][0])

# There are some helper functions to make accessing things "prettier"
# foo(bar, goo), tile(position(1), 1)
termList = json.loads("[{\"foo\" : [\"bar\", \"goo\"]}, {\"tile\" : [\"firstArg\", \"secondArg\"] }]")

# termName() gives the name of the term
print(termName(termList[0]))

# termArgs() gets the args for a term
print(termArgs(termList[0])[0])

